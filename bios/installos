local osid = 0
while fs.isDir("/os/"..tostring(osid)) do
  osid = osid + 1
end
osid = tostring(osid)

local function createVirtualShell()
  local shellDir = ""
  local shellPath = ".:/rom/programs"
  sandbox.shell = {}
  sandbox.shell.run = function(...)
    local line = table.concat({ ... }, " ")
    local words = {}
    local quoted = false
    for match in string.gmatch(line .. "\"", "(.-)\"") do
      if quoted then
        table.insert(words, match)
      else
        for m in string.gmatch(match, "[^ \t]+") do
          table.insert(words, m)
        end
      end
      quoted = not quoted
    end
    --sandbox.os.run(sandbox, words[1], table.unpack(words, 2)
    local path = sandbox.shell.resolveProgram(words[1])
    if path ~= nil then
      sandbox.os.run(sandbox, path, table.unpack(words, 2))
   	else
    	printError("No such program")
    	return false
    end
  end
  sandbox.shell.exit = function() end
  sandbox.shell.dir = function() return shellDir end
  sandbox.shell.setDir = function(newDir) shellDir = newDir end
  sandbox.shell.path = function() return shellPath end
  sandbox.shell.setPath = function(newPath) shellPath = newPath end
  sandbox.shell.resolve = function(_sPath)
    local sStartChar = string.sub( _sPath, 1, 1 )
    if sStartChar == "/" or sStartChar == "\\" then
      return sandbox.fs.combine( "", _sPath )
    else
      return sandbox.fs.combine( shellDir, _sPath )
    end
  end
  sandbox.shell.resolveProgram = function(command)
    local sStartChar = string.sub( command, 1, 1 )
    if sStartChar == "/" or sStartChar == "\\" then
    	local sPath = sandbox.fs.combine( "", command )
    	if sandbox.fs.exists( sPath ) and not sandbox.fs.isDir( sPath ) then
			return sPath
    	end
		return nil
    end
    for sPath in string.gmatch(shellPath, "[^:]+") do
    	sPath = sandbox.fs.combine(sandbox.shell.resolve(sPath), command)
    	if sandbox.fs.exists( sPath ) and not sandbox.fs.isDir( sPath ) then
        return sPath
    	end
    end
    return nil
  end
  -- None of the other methods are really necessary (might add later though)
end

local function pastebinInstall()
  term.clear()
  term.setCursorPos(5, 2)
  term.write("Pastebin code?")
  term.setCursorPos(2, 3)
  local code = read()
  local response = http.get("http://pastebin.com/raw/"..textutils.urlEncode(code))
  if response then
    local installer = response.readAll()
    response.close()
    
    term.clear()
    term.setCursorPos(5, 2)
    print("OS Name?")
    term.setCursorPos(2, 3)
    local osName = read()
    local handle = fs.open("/os/"..osid.."/config", "w")
    handle.writeLine("name = \""..osName.."\"")
    handle.close()
    
    term.clear()
    term.setCursorPos(1, 1)
    
    os.run(getEnv(), "/bios/sandbox", tostring(osid))
    createVirtualShell()
    mount.mountraw("rom")
    local func, err = load(installer, "installer", "t", sandbox)
    mount.unmountraw("rom")
    if func then
      fs.makeDir("/os/"..osid.."/fs")
      term.clear()
      term.setCursorPos(1, 1)
      local ok, err = pcall(func)
      if not ok then
        print("Error: "..err)
        print("Press any key to continue")
        os.pullEventRaw("key")
      end
    else
      term.clear()
      local notification = "Failed to compile that paste"
      term.setCursorPos(terminal.width / 2 - #notification / 2 + 1, terminal.height / 2 + 1)
      term.write(notification)
      local notification = "[*] Cancel"
      term.setCursorPos(terminal.width - #notification + 1, terminal.height)
      term.write(notification)
    end
  else
    term.clear()
    local notification = "Failed to get that paste"
    term.setCursorPos(terminal.width / 2 - #notification / 2 + 1, terminal.height / 2 + 1)
    term.write(notification)
    local notification = "[*] Cancel"
    term.setCursorPos(terminal.width - #notification + 1, terminal.height)
    term.write(notification)
  end
  return true
end

local function diskInstall()
  local menu = {}
  
  local path = "default"
  local driveName = nil
  index = 1
  for _, name in pairs(peripheral.getNames()) do
    if peripheral.getType(name) == "drive" and disk.hasData(name) and fs.exists(fs.combine(disk.getMountPath(name), "startup")) then    -- Gentlemen, we have ourselves a floppy disk filesystem!
      menu[index] = {
        text = (name:sub(1, 1):upper()..name:sub(2, -1):lower().." ["..disk.getMountPath(name).."]"):gsub("_", " "),
        selectable = true,
        selected = function() path = disk.getMountPath(name); driveName = name return true end,
        keyPressed = function() end
      }
      index = index + 1
    end
  end
  
  menu[index] = {
    text = "",
    selectable = false
  }
  
  menu[index + 1] = {
    text = "Cancel",
    selectable = true,
    selected = function() return true end,
    keyPressed = function() end
  }
  
  if index == 1 then
    menu[1] = menu[2]
    menu[2] = nil
  end
  
  doMenu(menu)
  
  if driveName ~= nil then
    fs.makeDir("/os/"..osid.."/fs")
    os.run(getEnv(), "/bios/sandbox", tostring(osid))
    createVirtualShell()
    
    term.clear()
    term.setCursorPos(5, 2)
    print("OS Name?")
    term.setCursorPos(2, 3)
    local osName = read()
    local handle = fs.open("/os/"..osid.."/config", "w")
    handle.writeLine("name = \""..osName.."\"")
    handle.close()
    
    term.clear()
    term.setCursorPos(1, 1)
    mount.mount(driveName)
    os.run(sandbox, fs.combine(path, "startup"))
    mount.unmount(driveName)
    print("\nDone installing "..osName)
    print("[*] Reboot")
    os.pullEventRaw("key")
    os.reboot()
  end
  return true
end

local function parseFullConfig(path)
  if not fs.exists(path) then
    return nil
  end
  result = {}
  h = fs.open(path, "r")
  if h then
    text = h.readAll()
    h.close()
    for k, v in text:gmatch("%s*([%w_-]+)%s*=%s*\"([^\"]*)\"") do
      result[k] = v
    end
  end
  return result
end

local menu = {}

if http ~= nil then
  menu[1] = {
    text = "Install from Pastebin",
    selectable = true,
    selected = function() local ok, err = pcall(pastebinInstall); if not ok then print(err); os.pullEventRaw("key") end end,
    keyPressed = function() end
  }
end

menu[#menu + 1] = {
  text = "Install from disk",
  selectable = true,
  selected = function() local ok, err = pcall(diskInstall); if not ok then print(err); os.pullEventRaw("key") end end,
  keyPressed = function() end
}

menu[#menu + 1] = {
  text = "",
  selectable = false
}

menu[#menu + 1] = {
  text = "Cancel",
  selectable = true,
  selected = function() return true end,
  keyPressed = function() end
}

local password = parseFullConfig(config).password

term.clear()
term.setCursorPos(5, 2)
write("Password")
term.setCursorPos(2, 3)
pw = read("*")

if pw == password then
  doMenu(menu)
end